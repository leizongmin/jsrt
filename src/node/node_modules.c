#include "node_modules.h"
#include <string.h>
#include "../runtime.h"
#include "../std/assert.h"
#include "../util/debug.h"
#include "process/process.h"

// Module dependency definitions
static const char* fs_deps[] = {"buffer", "stream", NULL};
static const char* stream_deps[] = {"events", "buffer", NULL};
static const char* net_deps[] = {"events", "stream", NULL};
static const char* dgram_deps[] = {"events", "buffer", NULL};
static const char* http_deps[] = {"events", "net", "stream", "buffer", NULL};
static const char* https_deps[] = {"http", "net", NULL};
static const char* zlib_deps[] = {"buffer", "stream", NULL};

// Module registry with dependencies
static NodeModuleEntry node_modules[] = {
    // Foundation modules (no dependencies)
    {"assert", JSRT_InitNodeAssert, js_node_assert_init, NULL, false, {0}},
    {"path", JSRT_InitNodePath, js_node_path_init, NULL, false, {0}},
    {"os", JSRT_InitNodeOs, js_node_os_init, NULL, false, {0}},
    {"util", JSRT_InitNodeUtil, js_node_util_init, NULL, false, {0}},
    {"querystring", JSRT_InitNodeQueryString, js_node_querystring_init, NULL, false, {0}},
    {"url", JSRT_InitNodeUrl, js_node_url_init, NULL, false, {0}},

    // Building blocks
    {"events", JSRT_InitNodeEvents, js_node_events_init, NULL, false, {0}},
    {"buffer", JSRT_InitNodeBuffer, js_node_buffer_init, NULL, false, {0}},
    {"process", jsrt_get_process_module, js_unified_process_init, NULL, false, {0}},

    // I/O modules - to be implemented later
    {"stream", JSRT_InitNodeStream, js_node_stream_init, stream_deps, false, {0}},
    {"stream/promises", JSRT_InitNodeStreamPromises, js_node_stream_promises_init, stream_deps, false, {0}},
    {"fs", JSRT_InitNodeFs, js_node_fs_init, fs_deps, false, {0}},

    // Networking modules
    {"net", JSRT_InitNodeNet, js_node_net_init, net_deps, false, {0}},
    {"dgram", JSRT_InitNodeDgram, js_node_dgram_init, dgram_deps, false, {0}},
    {"http", JSRT_InitNodeHttp, js_node_http_init, http_deps, false, {0}},
    {"https", JSRT_InitNodeHttps, js_node_https_init, https_deps, false, {0}},
    {"dns", JSRT_InitNodeDns, js_node_dns_init, NULL, false, {0}},

    // Advanced modules (Phase 5)
    {"crypto", JSRT_InitNodeCrypto, js_node_crypto_init, NULL, false},
    {"zlib", JSRT_InitNodeZlib, js_node_zlib_init, zlib_deps, false, {0}},

    {NULL, NULL, NULL, NULL, false}};

// Find module entry by name
static NodeModuleEntry* find_module(const char* name) {
  for (int i = 0; node_modules[i].name; i++) {
    if (strcmp(node_modules[i].name, name) == 0) {
      return &node_modules[i];
    }
  }
  return NULL;
}

// Initialize module with dependency checking
static JSValue init_module_with_deps(JSContext* ctx, NodeModuleEntry* entry) {
  // Check if already initialized - if so, return cached module
  if (entry->initialized) {
    return JS_DupValue(ctx, entry->cached_module);
  }

  // Initialize dependencies first
  if (entry->dependencies) {
    for (int i = 0; entry->dependencies[i]; i++) {
      NodeModuleEntry* dep = find_module(entry->dependencies[i]);
      if (dep && !dep->initialized) {
        JSValue dep_result = init_module_with_deps(ctx, dep);
        if (JS_IsException(dep_result)) {
          return dep_result;
        }
        JS_FreeValue(ctx, dep_result);
      }
    }
  }

  // Initialize this module
  if (entry->init_commonjs) {
    JSValue result = entry->init_commonjs(ctx);
    if (!JS_IsException(result)) {
      entry->initialized = true;
      entry->cached_module = JS_DupValue(ctx, result);  // Cache the result
    }
    return result;
  }

  return JS_UNDEFINED;
}

// CommonJS loader
JSValue JSRT_LoadNodeModuleCommonJS(JSContext* ctx, const char* module_name) {
  JSRT_Debug("Loading CommonJS node:%s module", module_name);

  NodeModuleEntry* entry = find_module(module_name);
  if (!entry) {
    JS_ThrowReferenceError(ctx, "Unknown node module: %s", module_name);
    return JS_EXCEPTION;
  }

  return init_module_with_deps(ctx, entry);
}

// ES Module loader
JSModuleDef* JSRT_LoadNodeModule(JSContext* ctx, const char* module_name) {
  JSRT_Debug("Loading ES node:%s module", module_name);

  NodeModuleEntry* entry = find_module(module_name);
  if (!entry || !entry->init_esm) {
    return NULL;
  }

  char full_name[256];
  snprintf(full_name, sizeof(full_name), "node:%s", module_name);

  JSModuleDef* m = JS_NewCModule(ctx, full_name, entry->init_esm);
  if (m) {
    // Register exports based on module
    if (strcmp(module_name, "path") == 0) {
      JS_AddModuleExport(ctx, m, "default");
      JS_AddModuleExport(ctx, m, "join");
      JS_AddModuleExport(ctx, m, "resolve");
      JS_AddModuleExport(ctx, m, "dirname");
      JS_AddModuleExport(ctx, m, "basename");
      JS_AddModuleExport(ctx, m, "extname");
      JS_AddModuleExport(ctx, m, "normalize");
      JS_AddModuleExport(ctx, m, "isAbsolute");
      JS_AddModuleExport(ctx, m, "relative");
      JS_AddModuleExport(ctx, m, "sep");
      JS_AddModuleExport(ctx, m, "delimiter");
    } else if (strcmp(module_name, "os") == 0) {
      JS_AddModuleExport(ctx, m, "default");
      JS_AddModuleExport(ctx, m, "arch");
      JS_AddModuleExport(ctx, m, "platform");
      JS_AddModuleExport(ctx, m, "type");
      JS_AddModuleExport(ctx, m, "release");
      JS_AddModuleExport(ctx, m, "hostname");
      JS_AddModuleExport(ctx, m, "tmpdir");
      JS_AddModuleExport(ctx, m, "homedir");
      JS_AddModuleExport(ctx, m, "userInfo");
      JS_AddModuleExport(ctx, m, "endianness");
      JS_AddModuleExport(ctx, m, "EOL");
    } else if (strcmp(module_name, "util") == 0) {
      JS_AddModuleExport(ctx, m, "default");
      JS_AddModuleExport(ctx, m, "format");
      JS_AddModuleExport(ctx, m, "inspect");
      JS_AddModuleExport(ctx, m, "isArray");
      JS_AddModuleExport(ctx, m, "isObject");
      JS_AddModuleExport(ctx, m, "isString");
      JS_AddModuleExport(ctx, m, "isNumber");
      JS_AddModuleExport(ctx, m, "isBoolean");
      JS_AddModuleExport(ctx, m, "isFunction");
      JS_AddModuleExport(ctx, m, "isNull");
      JS_AddModuleExport(ctx, m, "isUndefined");
      JS_AddModuleExport(ctx, m, "promisify");
    } else if (strcmp(module_name, "events") == 0) {
      JS_AddModuleExport(ctx, m, "EventEmitter");
      JS_AddModuleExport(ctx, m, "EventTarget");
      JS_AddModuleExport(ctx, m, "Event");
      JS_AddModuleExport(ctx, m, "CustomEvent");
      JS_AddModuleExport(ctx, m, "getEventListeners");
      JS_AddModuleExport(ctx, m, "once");
      JS_AddModuleExport(ctx, m, "setMaxListeners");
      JS_AddModuleExport(ctx, m, "getMaxListeners");
      JS_AddModuleExport(ctx, m, "addAbortListener");
      JS_AddModuleExport(ctx, m, "errorMonitor");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "buffer") == 0) {
      JS_AddModuleExport(ctx, m, "Buffer");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "stream") == 0) {
      JS_AddModuleExport(ctx, m, "Readable");
      JS_AddModuleExport(ctx, m, "Writable");
      JS_AddModuleExport(ctx, m, "Duplex");
      JS_AddModuleExport(ctx, m, "Transform");
      JS_AddModuleExport(ctx, m, "PassThrough");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "stream/promises") == 0) {
      JS_AddModuleExport(ctx, m, "pipeline");
      JS_AddModuleExport(ctx, m, "finished");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "fs") == 0) {
      // Basic sync operations
      JS_AddModuleExport(ctx, m, "readFileSync");
      JS_AddModuleExport(ctx, m, "writeFileSync");
      JS_AddModuleExport(ctx, m, "appendFileSync");
      JS_AddModuleExport(ctx, m, "existsSync");
      JS_AddModuleExport(ctx, m, "unlinkSync");

      // File operations
      JS_AddModuleExport(ctx, m, "copyFileSync");
      JS_AddModuleExport(ctx, m, "renameSync");
      JS_AddModuleExport(ctx, m, "accessSync");

      // Directory operations
      JS_AddModuleExport(ctx, m, "statSync");
      JS_AddModuleExport(ctx, m, "readdirSync");
      JS_AddModuleExport(ctx, m, "mkdirSync");
      JS_AddModuleExport(ctx, m, "rmdirSync");

      // File descriptor operations
      JS_AddModuleExport(ctx, m, "openSync");
      JS_AddModuleExport(ctx, m, "closeSync");
      JS_AddModuleExport(ctx, m, "readSync");
      JS_AddModuleExport(ctx, m, "writeSync");

      // File permissions and attributes
      JS_AddModuleExport(ctx, m, "chmodSync");
      JS_AddModuleExport(ctx, m, "chownSync");
      JS_AddModuleExport(ctx, m, "utimesSync");

      // Link operations
      JS_AddModuleExport(ctx, m, "linkSync");
      JS_AddModuleExport(ctx, m, "symlinkSync");
      JS_AddModuleExport(ctx, m, "readlinkSync");
      JS_AddModuleExport(ctx, m, "realpathSync");

      // Advanced file operations
      JS_AddModuleExport(ctx, m, "truncateSync");
      JS_AddModuleExport(ctx, m, "ftruncateSync");
      JS_AddModuleExport(ctx, m, "mkdtempSync");
      JS_AddModuleExport(ctx, m, "fsyncSync");
      JS_AddModuleExport(ctx, m, "fdatasyncSync");
      JS_AddModuleExport(ctx, m, "statfsSync");

      // Phase 1: New stat variants
      JS_AddModuleExport(ctx, m, "fstatSync");
      JS_AddModuleExport(ctx, m, "lstatSync");

      // Phase 1: FD-based permissions and times
      JS_AddModuleExport(ctx, m, "fchmodSync");
      JS_AddModuleExport(ctx, m, "fchownSync");
      JS_AddModuleExport(ctx, m, "lchownSync");
      JS_AddModuleExport(ctx, m, "futimesSync");
      JS_AddModuleExport(ctx, m, "lutimesSync");

      // Phase 1: Recursive operations
      JS_AddModuleExport(ctx, m, "rmSync");
      JS_AddModuleExport(ctx, m, "cpSync");

      // Phase 1: Directory operations
      JS_AddModuleExport(ctx, m, "opendirSync");

      // Phase 1: Vectored I/O
      JS_AddModuleExport(ctx, m, "readvSync");
      JS_AddModuleExport(ctx, m, "writevSync");

      // Async operations
      JS_AddModuleExport(ctx, m, "readFile");
      JS_AddModuleExport(ctx, m, "writeFile");
      JS_AddModuleExport(ctx, m, "appendFile");
      JS_AddModuleExport(ctx, m, "copyFile");
      JS_AddModuleExport(ctx, m, "rename");
      JS_AddModuleExport(ctx, m, "rmdir");
      JS_AddModuleExport(ctx, m, "access");

      JS_AddModuleExport(ctx, m, "constants");
      JS_AddModuleExport(ctx, m, "promises");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "querystring") == 0) {
      JS_AddModuleExport(ctx, m, "parse");
      JS_AddModuleExport(ctx, m, "stringify");
      JS_AddModuleExport(ctx, m, "escape");
      JS_AddModuleExport(ctx, m, "unescape");
      JS_AddModuleExport(ctx, m, "decode");
      JS_AddModuleExport(ctx, m, "encode");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "process") == 0) {
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "http") == 0) {
      JS_AddModuleExport(ctx, m, "createServer");
      JS_AddModuleExport(ctx, m, "request");
      JS_AddModuleExport(ctx, m, "get");
      JS_AddModuleExport(ctx, m, "Agent");
      JS_AddModuleExport(ctx, m, "globalAgent");
      JS_AddModuleExport(ctx, m, "Server");
      JS_AddModuleExport(ctx, m, "ServerResponse");
      JS_AddModuleExport(ctx, m, "IncomingMessage");
      JS_AddModuleExport(ctx, m, "ClientRequest");
      JS_AddModuleExport(ctx, m, "METHODS");
      JS_AddModuleExport(ctx, m, "STATUS_CODES");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "net") == 0) {
      JS_AddModuleExport(ctx, m, "createServer");
      JS_AddModuleExport(ctx, m, "connect");
      JS_AddModuleExport(ctx, m, "Socket");
      JS_AddModuleExport(ctx, m, "Server");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "dgram") == 0) {
      JS_AddModuleExport(ctx, m, "createSocket");
      JS_AddModuleExport(ctx, m, "Socket");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "https") == 0) {
      JS_AddModuleExport(ctx, m, "createServer");
      JS_AddModuleExport(ctx, m, "request");
      JS_AddModuleExport(ctx, m, "get");
      JS_AddModuleExport(ctx, m, "Agent");
      JS_AddModuleExport(ctx, m, "METHODS");
      JS_AddModuleExport(ctx, m, "STATUS_CODES");
      JS_AddModuleExport(ctx, m, "globalAgent");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "dns") == 0) {
      JS_AddModuleExport(ctx, m, "lookup");
      JS_AddModuleExport(ctx, m, "resolve");
      JS_AddModuleExport(ctx, m, "resolve4");
      JS_AddModuleExport(ctx, m, "resolve6");
      JS_AddModuleExport(ctx, m, "reverse");
      JS_AddModuleExport(ctx, m, "RRTYPE");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "crypto") == 0) {
      JS_AddModuleExport(ctx, m, "createHash");
      JS_AddModuleExport(ctx, m, "createHmac");
      JS_AddModuleExport(ctx, m, "createCipheriv");
      JS_AddModuleExport(ctx, m, "createDecipheriv");
      JS_AddModuleExport(ctx, m, "createSign");
      JS_AddModuleExport(ctx, m, "createVerify");
      JS_AddModuleExport(ctx, m, "randomBytes");
      JS_AddModuleExport(ctx, m, "randomUUID");
      JS_AddModuleExport(ctx, m, "pbkdf2");
      JS_AddModuleExport(ctx, m, "pbkdf2Sync");
      JS_AddModuleExport(ctx, m, "hkdf");
      JS_AddModuleExport(ctx, m, "hkdfSync");
      JS_AddModuleExport(ctx, m, "scrypt");
      JS_AddModuleExport(ctx, m, "scryptSync");
      JS_AddModuleExport(ctx, m, "createECDH");
      JS_AddModuleExport(ctx, m, "createDiffieHellman");
      JS_AddModuleExport(ctx, m, "createSecretKey");
      JS_AddModuleExport(ctx, m, "createPublicKey");
      JS_AddModuleExport(ctx, m, "createPrivateKey");
      JS_AddModuleExport(ctx, m, "constants");
      JS_AddModuleExport(ctx, m, "webcrypto");
      JS_AddModuleExport(ctx, m, "subtle");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "assert") == 0) {
      JS_AddModuleExport(ctx, m, "default");
      JS_AddModuleExport(ctx, m, "ok");
      JS_AddModuleExport(ctx, m, "equal");
      JS_AddModuleExport(ctx, m, "notEqual");
      JS_AddModuleExport(ctx, m, "strictEqual");
      JS_AddModuleExport(ctx, m, "notStrictEqual");
      JS_AddModuleExport(ctx, m, "deepEqual");
      JS_AddModuleExport(ctx, m, "notDeepEqual");
      JS_AddModuleExport(ctx, m, "throws");
      JS_AddModuleExport(ctx, m, "doesNotThrow");
      JS_AddModuleExport(ctx, m, "fail");
      JS_AddModuleExport(ctx, m, "ifError");
      JS_AddModuleExport(ctx, m, "match");
      JS_AddModuleExport(ctx, m, "doesNotMatch");
      JS_AddModuleExport(ctx, m, "strict");
    } else if (strcmp(module_name, "url") == 0) {
      JS_AddModuleExport(ctx, m, "URL");
      JS_AddModuleExport(ctx, m, "URLSearchParams");
      JS_AddModuleExport(ctx, m, "parse");
      JS_AddModuleExport(ctx, m, "format");
      JS_AddModuleExport(ctx, m, "resolve");
      JS_AddModuleExport(ctx, m, "domainToASCII");
      JS_AddModuleExport(ctx, m, "domainToUnicode");
      JS_AddModuleExport(ctx, m, "fileURLToPath");
      JS_AddModuleExport(ctx, m, "pathToFileURL");
      JS_AddModuleExport(ctx, m, "urlToHttpOptions");
      JS_AddModuleExport(ctx, m, "default");
    }
    // Add more module exports as needed
  }

  return m;
}

// Error handling implementation
const char* node_error_code_to_string(NodeErrorCode code) {
  switch (code) {
    case NODE_ERR_INVALID_ARG_TYPE:
      return "ERR_INVALID_ARG_TYPE";
    case NODE_ERR_MISSING_ARGS:
      return "ERR_MISSING_ARGS";
    case NODE_ERR_OUT_OF_RANGE:
      return "ERR_OUT_OF_RANGE";
    case NODE_ERR_INVALID_ARG_VALUE:
      return "ERR_INVALID_ARG_VALUE";
    case NODE_ERR_INVALID_CALLBACK:
      return "ERR_INVALID_CALLBACK";
    case NODE_ERR_SYSTEM_ERROR:
      return "ERR_SYSTEM_ERROR";
    default:
      return "ERR_UNKNOWN";
  }
}

JSValue node_throw_error(JSContext* ctx, NodeErrorCode code, const char* message) {
  JSValue error = JS_NewError(ctx);
  JS_SetPropertyStr(ctx, error, "code", JS_NewString(ctx, node_error_code_to_string(code)));
  JS_SetPropertyStr(ctx, error, "message", JS_NewString(ctx, message));
  return JS_Throw(ctx, error);
}

// Node.js assert module initialization (CommonJS)
JSValue JSRT_InitNodeAssert(JSContext* ctx) {
  return JSRT_CreateAssertModule(ctx);
}

// Node.js assert module initialization (ES Module)
int js_node_assert_init(JSContext* ctx, JSModuleDef* m) {
  JSValue assert_func = JSRT_CreateAssertModule(ctx);

  // Add default export
  JS_SetModuleExport(ctx, m, "default", JS_DupValue(ctx, assert_func));

  // Add named exports
  JS_SetModuleExport(ctx, m, "ok", JS_GetPropertyStr(ctx, assert_func, "ok"));
  JS_SetModuleExport(ctx, m, "equal", JS_GetPropertyStr(ctx, assert_func, "equal"));
  JS_SetModuleExport(ctx, m, "notEqual", JS_GetPropertyStr(ctx, assert_func, "notEqual"));
  JS_SetModuleExport(ctx, m, "strictEqual", JS_GetPropertyStr(ctx, assert_func, "strictEqual"));
  JS_SetModuleExport(ctx, m, "notStrictEqual", JS_GetPropertyStr(ctx, assert_func, "notStrictEqual"));
  JS_SetModuleExport(ctx, m, "deepEqual", JS_GetPropertyStr(ctx, assert_func, "deepEqual"));
  JS_SetModuleExport(ctx, m, "notDeepEqual", JS_GetPropertyStr(ctx, assert_func, "notDeepEqual"));
  JS_SetModuleExport(ctx, m, "throws", JS_GetPropertyStr(ctx, assert_func, "throws"));
  JS_SetModuleExport(ctx, m, "doesNotThrow", JS_GetPropertyStr(ctx, assert_func, "doesNotThrow"));
  JS_SetModuleExport(ctx, m, "fail", JS_GetPropertyStr(ctx, assert_func, "fail"));
  JS_SetModuleExport(ctx, m, "ifError", JS_GetPropertyStr(ctx, assert_func, "ifError"));
  JS_SetModuleExport(ctx, m, "match", JS_GetPropertyStr(ctx, assert_func, "match"));
  JS_SetModuleExport(ctx, m, "doesNotMatch", JS_GetPropertyStr(ctx, assert_func, "doesNotMatch"));
  JS_SetModuleExport(ctx, m, "strict", JS_GetPropertyStr(ctx, assert_func, "strict"));

  JS_FreeValue(ctx, assert_func);
  return 0;
}

// Setup Node.js global objects
void JSRT_SetupNodeGlobals(JSRuntime* rt, NodeCompatConfig* config) {
  if (!config->enable_node_globals || config->strict_mode) {
    return;
  }

  // Get context from runtime (simplified approach)
  JSContext* ctx = JS_GetRuntimeOpaque(rt);
  if (!ctx) {
    return;
  }

  // Add Node.js timer globals (setImmediate, clearImmediate)
  JSRT_AddNodeTimerGlobals(ctx);

  // TODO: Add process global when JSRT_InitNodeProcess is implemented
  // TODO: Add Buffer global when JSRT_InitNodeBuffer is implemented
  // TODO: Add Node.js timer globals (setImmediate, clearImmediate)
}

// Helper to check if a module name is a Node.js built-in module
bool JSRT_IsNodeModule(const char* module_name) {
  return find_module(module_name) != NULL;
}
