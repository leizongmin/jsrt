#include "node_modules.h"
#include <string.h>
#include "../util/debug.h"

// Module dependency definitions
static const char* fs_deps[] = {"buffer", "stream", NULL};
static const char* stream_deps[] = {"events", "buffer", NULL};
static const char* net_deps[] = {"events", "stream", NULL};
static const char* http_deps[] = {"net", "stream", "buffer", NULL};
static const char* https_deps[] = {"http", "net", NULL};

// Module registry with dependencies
static NodeModuleEntry node_modules[] = {
    // Foundation modules (no dependencies)
    {"path", JSRT_InitNodePath, js_node_path_init, NULL, false, {0}},
    {"os", JSRT_InitNodeOs, js_node_os_init, NULL, false, {0}},
    {"util", JSRT_InitNodeUtil, js_node_util_init, NULL, false, {0}},
    // {"querystring", NULL, NULL, NULL, false, {0}},

    // Building blocks - to be implemented later
    {"events", JSRT_InitNodeEvents, js_node_events_init, NULL, false, {0}},
    {"buffer", JSRT_InitNodeBuffer, js_node_buffer_init, NULL, false, {0}},
    // {"process", JSRT_InitNodeProcess, NULL, NULL, false, {0}},

    // I/O modules - to be implemented later
    {"stream", JSRT_InitNodeStream, js_node_stream_init, stream_deps, false, {0}},
    {"fs", JSRT_InitNodeFs, js_node_fs_init, fs_deps, false, {0}},

    // Networking modules
    {"net", JSRT_InitNodeNet, js_node_net_init, net_deps, false, {0}},
    {"http", JSRT_InitNodeHttp, js_node_http_init, http_deps, false, {0}},
    {"https", JSRT_InitNodeHttps, js_node_https_init, https_deps, false, {0}},
    {"dns", JSRT_InitNodeDns, js_node_dns_init, NULL, false, {0}},

    {NULL, NULL, NULL, NULL, false, {0}}};

// Find module entry by name
static NodeModuleEntry* find_module(const char* name) {
  for (int i = 0; node_modules[i].name; i++) {
    if (strcmp(node_modules[i].name, name) == 0) {
      return &node_modules[i];
    }
  }
  return NULL;
}

// Initialize module with dependency checking
static JSValue init_module_with_deps(JSContext* ctx, NodeModuleEntry* entry) {
  // Check if already initialized - if so, return cached module
  if (entry->initialized) {
    return JS_DupValue(ctx, entry->cached_module);
  }

  // Initialize dependencies first
  if (entry->dependencies) {
    for (int i = 0; entry->dependencies[i]; i++) {
      NodeModuleEntry* dep = find_module(entry->dependencies[i]);
      if (dep && !dep->initialized) {
        JSValue dep_result = init_module_with_deps(ctx, dep);
        if (JS_IsException(dep_result)) {
          return dep_result;
        }
        JS_FreeValue(ctx, dep_result);
      }
    }
  }

  // Initialize this module
  if (entry->init_commonjs) {
    JSValue result = entry->init_commonjs(ctx);
    if (!JS_IsException(result)) {
      entry->initialized = true;
      entry->cached_module = JS_DupValue(ctx, result);  // Cache the result
    }
    return result;
  }

  return JS_UNDEFINED;
}

// CommonJS loader
JSValue JSRT_LoadNodeModuleCommonJS(JSContext* ctx, const char* module_name) {
  JSRT_Debug("Loading CommonJS node:%s module", module_name);

  NodeModuleEntry* entry = find_module(module_name);
  if (!entry) {
    JS_ThrowReferenceError(ctx, "Unknown node module: %s", module_name);
    return JS_EXCEPTION;
  }

  return init_module_with_deps(ctx, entry);
}

// ES Module loader
JSModuleDef* JSRT_LoadNodeModule(JSContext* ctx, const char* module_name) {
  JSRT_Debug("Loading ES node:%s module", module_name);

  NodeModuleEntry* entry = find_module(module_name);
  if (!entry || !entry->init_esm) {
    return NULL;
  }

  char full_name[256];
  snprintf(full_name, sizeof(full_name), "node:%s", module_name);

  JSModuleDef* m = JS_NewCModule(ctx, full_name, entry->init_esm);
  if (m) {
    // Register exports based on module
    if (strcmp(module_name, "path") == 0) {
      JS_AddModuleExport(ctx, m, "default");
      JS_AddModuleExport(ctx, m, "join");
      JS_AddModuleExport(ctx, m, "resolve");
      JS_AddModuleExport(ctx, m, "dirname");
      JS_AddModuleExport(ctx, m, "basename");
      JS_AddModuleExport(ctx, m, "extname");
      JS_AddModuleExport(ctx, m, "normalize");
      JS_AddModuleExport(ctx, m, "isAbsolute");
      JS_AddModuleExport(ctx, m, "relative");
      JS_AddModuleExport(ctx, m, "sep");
      JS_AddModuleExport(ctx, m, "delimiter");
    } else if (strcmp(module_name, "os") == 0) {
      JS_AddModuleExport(ctx, m, "default");
      JS_AddModuleExport(ctx, m, "arch");
      JS_AddModuleExport(ctx, m, "platform");
      JS_AddModuleExport(ctx, m, "type");
      JS_AddModuleExport(ctx, m, "release");
      JS_AddModuleExport(ctx, m, "hostname");
      JS_AddModuleExport(ctx, m, "tmpdir");
      JS_AddModuleExport(ctx, m, "homedir");
      JS_AddModuleExport(ctx, m, "userInfo");
      JS_AddModuleExport(ctx, m, "endianness");
      JS_AddModuleExport(ctx, m, "EOL");
    } else if (strcmp(module_name, "util") == 0) {
      JS_AddModuleExport(ctx, m, "default");
      JS_AddModuleExport(ctx, m, "format");
      JS_AddModuleExport(ctx, m, "inspect");
      JS_AddModuleExport(ctx, m, "isArray");
      JS_AddModuleExport(ctx, m, "isObject");
      JS_AddModuleExport(ctx, m, "isString");
      JS_AddModuleExport(ctx, m, "isNumber");
      JS_AddModuleExport(ctx, m, "isBoolean");
      JS_AddModuleExport(ctx, m, "isFunction");
      JS_AddModuleExport(ctx, m, "isNull");
      JS_AddModuleExport(ctx, m, "isUndefined");
      JS_AddModuleExport(ctx, m, "promisify");
    } else if (strcmp(module_name, "events") == 0) {
      JS_AddModuleExport(ctx, m, "EventEmitter");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "buffer") == 0) {
      JS_AddModuleExport(ctx, m, "Buffer");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "stream") == 0) {
      JS_AddModuleExport(ctx, m, "Readable");
      JS_AddModuleExport(ctx, m, "Writable");
      JS_AddModuleExport(ctx, m, "Transform");
      JS_AddModuleExport(ctx, m, "PassThrough");
      JS_AddModuleExport(ctx, m, "default");
    } else if (strcmp(module_name, "fs") == 0) {
      JS_AddModuleExport(ctx, m, "readFileSync");
      JS_AddModuleExport(ctx, m, "writeFileSync");
      JS_AddModuleExport(ctx, m, "existsSync");
      JS_AddModuleExport(ctx, m, "statSync");
      JS_AddModuleExport(ctx, m, "readdirSync");
      JS_AddModuleExport(ctx, m, "mkdirSync");
      JS_AddModuleExport(ctx, m, "unlinkSync");
      JS_AddModuleExport(ctx, m, "constants");
      JS_AddModuleExport(ctx, m, "default");
    }
    // Add more module exports as needed
  }

  return m;
}

// Error handling implementation
const char* node_error_code_to_string(NodeErrorCode code) {
  switch (code) {
    case NODE_ERR_INVALID_ARG_TYPE:
      return "ERR_INVALID_ARG_TYPE";
    case NODE_ERR_MISSING_ARGS:
      return "ERR_MISSING_ARGS";
    case NODE_ERR_OUT_OF_RANGE:
      return "ERR_OUT_OF_RANGE";
    case NODE_ERR_INVALID_ARG_VALUE:
      return "ERR_INVALID_ARG_VALUE";
    case NODE_ERR_INVALID_CALLBACK:
      return "ERR_INVALID_CALLBACK";
    case NODE_ERR_SYSTEM_ERROR:
      return "ERR_SYSTEM_ERROR";
    default:
      return "ERR_UNKNOWN";
  }
}

JSValue node_throw_error(JSContext* ctx, NodeErrorCode code, const char* message) {
  JSValue error = JS_NewError(ctx);
  JS_SetPropertyStr(ctx, error, "code", JS_NewString(ctx, node_error_code_to_string(code)));
  JS_SetPropertyStr(ctx, error, "message", JS_NewString(ctx, message));
  return JS_Throw(ctx, error);
}

// Setup Node.js global objects
void JSRT_SetupNodeGlobals(JSRuntime* rt, NodeCompatConfig* config) {
  if (!config->enable_node_globals || config->strict_mode) {
    return;
  }

  // For now, just setup the configuration but don't add globals
  // since process and Buffer modules are not implemented yet
  // This will be expanded as more modules are implemented

  // TODO: Add process global when JSRT_InitNodeProcess is implemented
  // TODO: Add Buffer global when JSRT_InitNodeBuffer is implemented
  // TODO: Add Node.js timer globals (setImmediate, clearImmediate)
}