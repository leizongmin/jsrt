#ifndef __JSRT_NODE_MODULES_H__
#define __JSRT_NODE_MODULES_H__

#include <quickjs.h>
#include <stdbool.h>

// Unified module entry structure
typedef struct {
  const char* name;
  JSValue (*init_commonjs)(JSContext* ctx);
  int (*init_esm)(JSContext* ctx, JSModuleDef* m);
  const char** dependencies;
  bool initialized;
  JSValue cached_module;  // Cached module for CommonJS
} NodeModuleEntry;

// Node module initialization functions
JSValue JSRT_InitNodePath(JSContext* ctx);
JSValue JSRT_InitNodeOs(JSContext* ctx);
JSValue JSRT_InitNodeUtil(JSContext* ctx);
JSValue JSRT_InitNodeEvents(JSContext* ctx);
JSValue JSRT_InitNodeBuffer(JSContext* ctx);
JSValue JSRT_InitNodeProcess(JSContext* ctx);
JSValue JSRT_InitNodeFs(JSContext* ctx);
JSValue JSRT_InitNodeStream(JSContext* ctx);
JSValue JSRT_InitNodeNet(JSContext* ctx);
JSValue JSRT_InitNodeHttp(JSContext* ctx);
JSValue JSRT_InitNodeDns(JSContext* ctx);
JSValue JSRT_InitNodeHttps(JSContext* ctx);
JSValue JSRT_InitNodeCrypto(JSContext* ctx);
JSValue JSRT_InitNodeProcess(JSContext* ctx);
JSValue JSRT_InitNodeQueryString(JSContext* ctx);

// ES Module init functions
int js_node_path_init(JSContext* ctx, JSModuleDef* m);
int js_node_os_init(JSContext* ctx, JSModuleDef* m);
int js_node_util_init(JSContext* ctx, JSModuleDef* m);
int js_node_events_init(JSContext* ctx, JSModuleDef* m);
int js_node_buffer_init(JSContext* ctx, JSModuleDef* m);
int js_node_stream_init(JSContext* ctx, JSModuleDef* m);
int js_node_fs_init(JSContext* ctx, JSModuleDef* m);
int js_node_net_init(JSContext* ctx, JSModuleDef* m);
int js_node_http_init(JSContext* ctx, JSModuleDef* m);
int js_node_dns_init(JSContext* ctx, JSModuleDef* m);
int js_node_https_init(JSContext* ctx, JSModuleDef* m);
int js_node_crypto_init(JSContext* ctx, JSModuleDef* m);
int js_node_process_init(JSContext* ctx, JSModuleDef* m);
int js_node_querystring_init(JSContext* ctx, JSModuleDef* m);

// Main loader for Node.js modules
JSModuleDef* JSRT_LoadNodeModule(JSContext* ctx, const char* module_name);
JSValue JSRT_LoadNodeModuleCommonJS(JSContext* ctx, const char* module_name);

// Node.js timer functions
JSValue JSRT_InitNodeTimers(JSContext* ctx);
void JSRT_AddNodeTimerGlobals(JSContext* ctx);

// Configuration
typedef struct {
  bool enable_node_globals;  // Enable process, Buffer as globals
  bool strict_mode;          // Strict compatibility mode
} NodeCompatConfig;

void JSRT_SetupNodeGlobals(JSRuntime* rt, NodeCompatConfig* config);

// Error handling
typedef enum {
  NODE_ERR_INVALID_ARG_TYPE,
  NODE_ERR_MISSING_ARGS,
  NODE_ERR_OUT_OF_RANGE,
  NODE_ERR_INVALID_ARG_VALUE,
  NODE_ERR_INVALID_CALLBACK,
  NODE_ERR_SYSTEM_ERROR
} NodeErrorCode;

JSValue node_throw_error(JSContext* ctx, NodeErrorCode code, const char* message);
const char* node_error_code_to_string(NodeErrorCode code);

// Memory management helpers
#define CHECK_EXCEPTION_RET(ctx, val) \
  if (JS_IsException(val)) {          \
    return JS_EXCEPTION;              \
  }

#define NODE_ARG_REQUIRE_STRING(ctx, arg, name)                                        \
  if (!JS_IsString(arg)) {                                                             \
    return node_throw_error(ctx, NODE_ERR_INVALID_ARG_TYPE, name " must be a string"); \
  }

#define NODE_ARG_REQUIRE_NUMBER(ctx, arg, name)                                        \
  if (!JS_IsNumber(arg)) {                                                             \
    return node_throw_error(ctx, NODE_ERR_INVALID_ARG_TYPE, name " must be a number"); \
  }

#endif  // __JSRT_NODE_MODULES_H__