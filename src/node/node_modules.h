#ifndef __JSRT_NODE_MODULES_H__
#define __JSRT_NODE_MODULES_H__

#include <quickjs.h>
#include <stdbool.h>

// Unified module entry structure
typedef struct {
  const char* name;
  JSValue (*init_commonjs)(JSContext* ctx);
  int (*init_esm)(JSContext* ctx, JSModuleDef* m);
  const char** dependencies;
  bool initialized;
  JSValue cached_module;  // Cached module for CommonJS
} NodeModuleEntry;

// Node module initialization functions
JSValue JSRT_InitNodePath(JSContext* ctx);
JSValue JSRT_InitNodeOs(JSContext* ctx);
JSValue JSRT_InitNodeUtil(JSContext* ctx);
JSValue JSRT_InitNodeEvents(JSContext* ctx);
JSValue JSRT_InitNodeBuffer(JSContext* ctx);
JSValue JSRT_InitNodeProcess(JSContext* ctx);
JSValue JSRT_InitNodeFs(JSContext* ctx);
JSValue JSRT_InitNodeStream(JSContext* ctx);
JSValue JSRT_InitNodeStreamPromises(JSContext* ctx);
JSValue JSRT_InitNodeTimers(JSContext* ctx);
JSValue JSRT_InitNodeTimersPromises(JSContext* ctx);
JSValue JSRT_InitNodeAsyncHooks(JSContext* ctx);
JSValue JSRT_InitNodeNet(JSContext* ctx);
JSValue JSRT_InitNodeHttp(JSContext* ctx);
JSValue JSRT_InitNodeDns(JSContext* ctx);
JSValue JSRT_InitNodeHttps(JSContext* ctx);
JSValue JSRT_InitNodeHttp2(JSContext* ctx);
JSValue JSRT_InitNodeCrypto(JSContext* ctx);
JSValue JSRT_InitNodeProcess(JSContext* ctx);
JSValue JSRT_InitNodeQueryString(JSContext* ctx);
JSValue JSRT_InitNodeAssert(JSContext* ctx);
JSValue JSRT_InitNodeUrl(JSContext* ctx);
JSValue JSRT_InitNodeDgram(JSContext* ctx);
JSValue JSRT_InitNodeZlib(JSContext* ctx);
JSValue JSRT_InitNodeWASI(JSContext* ctx);
JSValue JSRT_InitNodeChildProcess(JSContext* ctx);
JSValue JSRT_InitNodeModule(JSContext* ctx);
JSValue JSRT_InitNodeVM(JSContext* ctx);
JSValue JSRT_InitNodeConstants(JSContext* ctx);
JSValue JSRT_InitNodeStringDecoder(JSContext* ctx);
JSValue JSRT_InitNodeDiagnosticsChannel(JSContext* ctx);
JSValue JSRT_InitNodeReadline(JSContext* ctx);
JSValue JSRT_InitNodeTls(JSContext* ctx);
JSValue JSRT_InitResolve(JSContext* ctx);

// Unified process module functions
JSValue jsrt_init_node_process(JSContext* ctx);

// ES Module init functions
int js_node_path_init(JSContext* ctx, JSModuleDef* m);
int js_node_os_init(JSContext* ctx, JSModuleDef* m);
int js_node_util_init(JSContext* ctx, JSModuleDef* m);
int js_node_events_init(JSContext* ctx, JSModuleDef* m);
int js_node_buffer_init(JSContext* ctx, JSModuleDef* m);
int js_node_stream_init(JSContext* ctx, JSModuleDef* m);
int js_node_stream_promises_init(JSContext* ctx, JSModuleDef* m);
int js_node_timers_init(JSContext* ctx, JSModuleDef* m);
int js_node_timers_promises_init(JSContext* ctx, JSModuleDef* m);
int js_node_async_hooks_init(JSContext* ctx, JSModuleDef* m);
int js_node_fs_init(JSContext* ctx, JSModuleDef* m);
int js_node_fs_promises_init(JSContext* ctx, JSModuleDef* m);
int js_node_net_init(JSContext* ctx, JSModuleDef* m);
int js_node_http_init(JSContext* ctx, JSModuleDef* m);
int js_node_dns_init(JSContext* ctx, JSModuleDef* m);
int js_node_https_init(JSContext* ctx, JSModuleDef* m);
int js_node_http2_init(JSContext* ctx, JSModuleDef* m);
int js_node_crypto_init(JSContext* ctx, JSModuleDef* m);
int js_node_process_init(JSContext* ctx, JSModuleDef* m);
int js_node_querystring_init(JSContext* ctx, JSModuleDef* m);
int js_node_assert_init(JSContext* ctx, JSModuleDef* m);
int js_node_url_init(JSContext* ctx, JSModuleDef* m);
int js_node_dgram_init(JSContext* ctx, JSModuleDef* m);
int js_node_zlib_init(JSContext* ctx, JSModuleDef* m);
int js_node_wasi_init(JSContext* ctx, JSModuleDef* m);
int js_node_child_process_init(JSContext* ctx, JSModuleDef* m);
int js_node_module_init(JSContext* ctx, JSModuleDef* m);
int js_node_vm_init(JSContext* ctx, JSModuleDef* m);
int js_node_constants_init(JSContext* ctx, JSModuleDef* m);
int js_node_string_decoder_init(JSContext* ctx, JSModuleDef* m);
int js_node_diagnostics_channel_init(JSContext* ctx, JSModuleDef* m);
int js_node_readline_init(JSContext* ctx, JSModuleDef* m);
int js_node_tls_init(JSContext* ctx, JSModuleDef* m);
JSModuleDef* js_init_module_node_url(JSContext* ctx, const char* module_name);

// Main loader for Node.js modules
JSModuleDef* JSRT_LoadNodeModule(JSContext* ctx, const char* module_name);
JSValue JSRT_LoadNodeModuleCommonJS(JSContext* ctx, const char* module_name);

// Helper to check if a module name is a Node.js built-in module
bool JSRT_IsNodeModule(const char* module_name);

// Get count of built-in Node.js modules
int JSRT_GetNodeModuleCount(void);

// Get built-in module name by index (0-based)
const char* JSRT_GetNodeModuleName(int index);

// Node.js timer functions
JSValue JSRT_InitNodeTimers(JSContext* ctx);
void JSRT_AddNodeTimerGlobals(JSContext* ctx);

// Configuration
typedef struct {
  bool enable_node_globals;  // Enable process, Buffer as globals
  bool strict_mode;          // Strict compatibility mode
} NodeCompatConfig;

void JSRT_SetupNodeGlobals(JSRuntime* rt, NodeCompatConfig* config);

// Error handling
typedef enum {
  NODE_ERR_INVALID_ARG_TYPE,
  NODE_ERR_MISSING_ARGS,
  NODE_ERR_OUT_OF_RANGE,
  NODE_ERR_INVALID_ARG_VALUE,
  NODE_ERR_INVALID_CALLBACK,
  NODE_ERR_SYSTEM_ERROR
} NodeErrorCode;

JSValue node_throw_error(JSContext* ctx, NodeErrorCode code, const char* message);
const char* node_error_code_to_string(NodeErrorCode code);

// Memory management helpers
#define CHECK_EXCEPTION_RET(ctx, val) \
  if (JS_IsException(val)) {          \
    return JS_EXCEPTION;              \
  }

#define NODE_ARG_REQUIRE_STRING(ctx, arg, name)                                        \
  if (!JS_IsString(arg)) {                                                             \
    return node_throw_error(ctx, NODE_ERR_INVALID_ARG_TYPE, name " must be a string"); \
  }

#define NODE_ARG_REQUIRE_NUMBER(ctx, arg, name)                                        \
  if (!JS_IsNumber(arg)) {                                                             \
    return node_throw_error(ctx, NODE_ERR_INVALID_ARG_TYPE, name " must be a number"); \
  }

#endif  // __JSRT_NODE_MODULES_H__
